// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package commands

import (
	"context"
	"github.com/google/uuid"
	"github.com/indigowar/food_out/services/menu/domain"
	"sync"
)

// Ensure, that MenuStoragePortMock does implement MenuStoragePort.
// If this is not the case, regenerate this file with moq.
var _ MenuStoragePort = &MenuStoragePortMock{}

// MenuStoragePortMock is a mock implementation of MenuStoragePort.
//
//	func TestSomethingThatUsesMenuStoragePort(t *testing.T) {
//
//		// make and configure a mocked MenuStoragePort
//		mockedMenuStoragePort := &MenuStoragePortMock{
//			AddMenuFunc: func(ctx context.Context, menu *domain.Menu) error {
//				panic("mock out the AddMenu method")
//			},
//			DeleteMenuFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the DeleteMenu method")
//			},
//			GetMenuFunc: func(ctx context.Context, id uuid.UUID) (*domain.Menu, error) {
//				panic("mock out the GetMenu method")
//			},
//			GetMenuByRestaurantFunc: func(ctx context.Context, restaurant uuid.UUID) ([]*domain.Menu, error) {
//				panic("mock out the GetMenuByRestaurant method")
//			},
//			UpdateMenuFunc: func(ctx context.Context, menu *domain.Menu) error {
//				panic("mock out the UpdateMenu method")
//			},
//		}
//
//		// use mockedMenuStoragePort in code that requires MenuStoragePort
//		// and then make assertions.
//
//	}
type MenuStoragePortMock struct {
	// AddMenuFunc mocks the AddMenu method.
	AddMenuFunc func(ctx context.Context, menu *domain.Menu) error

	// DeleteMenuFunc mocks the DeleteMenu method.
	DeleteMenuFunc func(ctx context.Context, id uuid.UUID) error

	// GetMenuFunc mocks the GetMenu method.
	GetMenuFunc func(ctx context.Context, id uuid.UUID) (*domain.Menu, error)

	// GetMenuByRestaurantFunc mocks the GetMenuByRestaurant method.
	GetMenuByRestaurantFunc func(ctx context.Context, restaurant uuid.UUID) ([]*domain.Menu, error)

	// UpdateMenuFunc mocks the UpdateMenu method.
	UpdateMenuFunc func(ctx context.Context, menu *domain.Menu) error

	// calls tracks calls to the methods.
	calls struct {
		// AddMenu holds details about calls to the AddMenu method.
		AddMenu []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Menu is the menu argument value.
			Menu *domain.Menu
		}
		// DeleteMenu holds details about calls to the DeleteMenu method.
		DeleteMenu []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetMenu holds details about calls to the GetMenu method.
		GetMenu []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// GetMenuByRestaurant holds details about calls to the GetMenuByRestaurant method.
		GetMenuByRestaurant []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Restaurant is the restaurant argument value.
			Restaurant uuid.UUID
		}
		// UpdateMenu holds details about calls to the UpdateMenu method.
		UpdateMenu []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// Menu is the menu argument value.
			Menu *domain.Menu
		}
	}
	lockAddMenu             sync.RWMutex
	lockDeleteMenu          sync.RWMutex
	lockGetMenu             sync.RWMutex
	lockGetMenuByRestaurant sync.RWMutex
	lockUpdateMenu          sync.RWMutex
}

// AddMenu calls AddMenuFunc.
func (mock *MenuStoragePortMock) AddMenu(ctx context.Context, menu *domain.Menu) error {
	if mock.AddMenuFunc == nil {
		panic("MenuStoragePortMock.AddMenuFunc: method is nil but MenuStoragePort.AddMenu was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Menu *domain.Menu
	}{
		Ctx:  ctx,
		Menu: menu,
	}
	mock.lockAddMenu.Lock()
	mock.calls.AddMenu = append(mock.calls.AddMenu, callInfo)
	mock.lockAddMenu.Unlock()
	return mock.AddMenuFunc(ctx, menu)
}

// AddMenuCalls gets all the calls that were made to AddMenu.
// Check the length with:
//
//	len(mockedMenuStoragePort.AddMenuCalls())
func (mock *MenuStoragePortMock) AddMenuCalls() []struct {
	Ctx  context.Context
	Menu *domain.Menu
} {
	var calls []struct {
		Ctx  context.Context
		Menu *domain.Menu
	}
	mock.lockAddMenu.RLock()
	calls = mock.calls.AddMenu
	mock.lockAddMenu.RUnlock()
	return calls
}

// DeleteMenu calls DeleteMenuFunc.
func (mock *MenuStoragePortMock) DeleteMenu(ctx context.Context, id uuid.UUID) error {
	if mock.DeleteMenuFunc == nil {
		panic("MenuStoragePortMock.DeleteMenuFunc: method is nil but MenuStoragePort.DeleteMenu was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockDeleteMenu.Lock()
	mock.calls.DeleteMenu = append(mock.calls.DeleteMenu, callInfo)
	mock.lockDeleteMenu.Unlock()
	return mock.DeleteMenuFunc(ctx, id)
}

// DeleteMenuCalls gets all the calls that were made to DeleteMenu.
// Check the length with:
//
//	len(mockedMenuStoragePort.DeleteMenuCalls())
func (mock *MenuStoragePortMock) DeleteMenuCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockDeleteMenu.RLock()
	calls = mock.calls.DeleteMenu
	mock.lockDeleteMenu.RUnlock()
	return calls
}

// GetMenu calls GetMenuFunc.
func (mock *MenuStoragePortMock) GetMenu(ctx context.Context, id uuid.UUID) (*domain.Menu, error) {
	if mock.GetMenuFunc == nil {
		panic("MenuStoragePortMock.GetMenuFunc: method is nil but MenuStoragePort.GetMenu was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockGetMenu.Lock()
	mock.calls.GetMenu = append(mock.calls.GetMenu, callInfo)
	mock.lockGetMenu.Unlock()
	return mock.GetMenuFunc(ctx, id)
}

// GetMenuCalls gets all the calls that were made to GetMenu.
// Check the length with:
//
//	len(mockedMenuStoragePort.GetMenuCalls())
func (mock *MenuStoragePortMock) GetMenuCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockGetMenu.RLock()
	calls = mock.calls.GetMenu
	mock.lockGetMenu.RUnlock()
	return calls
}

// GetMenuByRestaurant calls GetMenuByRestaurantFunc.
func (mock *MenuStoragePortMock) GetMenuByRestaurant(ctx context.Context, restaurant uuid.UUID) ([]*domain.Menu, error) {
	if mock.GetMenuByRestaurantFunc == nil {
		panic("MenuStoragePortMock.GetMenuByRestaurantFunc: method is nil but MenuStoragePort.GetMenuByRestaurant was just called")
	}
	callInfo := struct {
		Ctx        context.Context
		Restaurant uuid.UUID
	}{
		Ctx:        ctx,
		Restaurant: restaurant,
	}
	mock.lockGetMenuByRestaurant.Lock()
	mock.calls.GetMenuByRestaurant = append(mock.calls.GetMenuByRestaurant, callInfo)
	mock.lockGetMenuByRestaurant.Unlock()
	return mock.GetMenuByRestaurantFunc(ctx, restaurant)
}

// GetMenuByRestaurantCalls gets all the calls that were made to GetMenuByRestaurant.
// Check the length with:
//
//	len(mockedMenuStoragePort.GetMenuByRestaurantCalls())
func (mock *MenuStoragePortMock) GetMenuByRestaurantCalls() []struct {
	Ctx        context.Context
	Restaurant uuid.UUID
} {
	var calls []struct {
		Ctx        context.Context
		Restaurant uuid.UUID
	}
	mock.lockGetMenuByRestaurant.RLock()
	calls = mock.calls.GetMenuByRestaurant
	mock.lockGetMenuByRestaurant.RUnlock()
	return calls
}

// UpdateMenu calls UpdateMenuFunc.
func (mock *MenuStoragePortMock) UpdateMenu(ctx context.Context, menu *domain.Menu) error {
	if mock.UpdateMenuFunc == nil {
		panic("MenuStoragePortMock.UpdateMenuFunc: method is nil but MenuStoragePort.UpdateMenu was just called")
	}
	callInfo := struct {
		Ctx  context.Context
		Menu *domain.Menu
	}{
		Ctx:  ctx,
		Menu: menu,
	}
	mock.lockUpdateMenu.Lock()
	mock.calls.UpdateMenu = append(mock.calls.UpdateMenu, callInfo)
	mock.lockUpdateMenu.Unlock()
	return mock.UpdateMenuFunc(ctx, menu)
}

// UpdateMenuCalls gets all the calls that were made to UpdateMenu.
// Check the length with:
//
//	len(mockedMenuStoragePort.UpdateMenuCalls())
func (mock *MenuStoragePortMock) UpdateMenuCalls() []struct {
	Ctx  context.Context
	Menu *domain.Menu
} {
	var calls []struct {
		Ctx  context.Context
		Menu *domain.Menu
	}
	mock.lockUpdateMenu.RLock()
	calls = mock.calls.UpdateMenu
	mock.lockUpdateMenu.RUnlock()
	return calls
}
