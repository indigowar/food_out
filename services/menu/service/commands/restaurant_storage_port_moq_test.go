// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package commands

import (
	"context"
	"github.com/google/uuid"
	"sync"
)

// Ensure, that RestaurantStoragePortMock does implement RestaurantStoragePort.
// If this is not the case, regenerate this file with moq.
var _ RestaurantStoragePort = &RestaurantStoragePortMock{}

// RestaurantStoragePortMock is a mock implementation of RestaurantStoragePort.
//
//	func TestSomethingThatUsesRestaurantStoragePort(t *testing.T) {
//
//		// make and configure a mocked RestaurantStoragePort
//		mockedRestaurantStoragePort := &RestaurantStoragePortMock{
//			AddRestaurantFunc: func(ctx context.Context, id uuid.UUID) error {
//				panic("mock out the AddRestaurant method")
//			},
//			RestaurantExistsFunc: func(ctx context.Context, id uuid.UUID) (bool, error) {
//				panic("mock out the RestaurantExists method")
//			},
//		}
//
//		// use mockedRestaurantStoragePort in code that requires RestaurantStoragePort
//		// and then make assertions.
//
//	}
type RestaurantStoragePortMock struct {
	// AddRestaurantFunc mocks the AddRestaurant method.
	AddRestaurantFunc func(ctx context.Context, id uuid.UUID) error

	// RestaurantExistsFunc mocks the RestaurantExists method.
	RestaurantExistsFunc func(ctx context.Context, id uuid.UUID) (bool, error)

	// calls tracks calls to the methods.
	calls struct {
		// AddRestaurant holds details about calls to the AddRestaurant method.
		AddRestaurant []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
		// RestaurantExists holds details about calls to the RestaurantExists method.
		RestaurantExists []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// ID is the id argument value.
			ID uuid.UUID
		}
	}
	lockAddRestaurant    sync.RWMutex
	lockRestaurantExists sync.RWMutex
}

// AddRestaurant calls AddRestaurantFunc.
func (mock *RestaurantStoragePortMock) AddRestaurant(ctx context.Context, id uuid.UUID) error {
	if mock.AddRestaurantFunc == nil {
		panic("RestaurantStoragePortMock.AddRestaurantFunc: method is nil but RestaurantStoragePort.AddRestaurant was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockAddRestaurant.Lock()
	mock.calls.AddRestaurant = append(mock.calls.AddRestaurant, callInfo)
	mock.lockAddRestaurant.Unlock()
	return mock.AddRestaurantFunc(ctx, id)
}

// AddRestaurantCalls gets all the calls that were made to AddRestaurant.
// Check the length with:
//
//	len(mockedRestaurantStoragePort.AddRestaurantCalls())
func (mock *RestaurantStoragePortMock) AddRestaurantCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockAddRestaurant.RLock()
	calls = mock.calls.AddRestaurant
	mock.lockAddRestaurant.RUnlock()
	return calls
}

// RestaurantExists calls RestaurantExistsFunc.
func (mock *RestaurantStoragePortMock) RestaurantExists(ctx context.Context, id uuid.UUID) (bool, error) {
	if mock.RestaurantExistsFunc == nil {
		panic("RestaurantStoragePortMock.RestaurantExistsFunc: method is nil but RestaurantStoragePort.RestaurantExists was just called")
	}
	callInfo := struct {
		Ctx context.Context
		ID  uuid.UUID
	}{
		Ctx: ctx,
		ID:  id,
	}
	mock.lockRestaurantExists.Lock()
	mock.calls.RestaurantExists = append(mock.calls.RestaurantExists, callInfo)
	mock.lockRestaurantExists.Unlock()
	return mock.RestaurantExistsFunc(ctx, id)
}

// RestaurantExistsCalls gets all the calls that were made to RestaurantExists.
// Check the length with:
//
//	len(mockedRestaurantStoragePort.RestaurantExistsCalls())
func (mock *RestaurantStoragePortMock) RestaurantExistsCalls() []struct {
	Ctx context.Context
	ID  uuid.UUID
} {
	var calls []struct {
		Ctx context.Context
		ID  uuid.UUID
	}
	mock.lockRestaurantExists.RLock()
	calls = mock.calls.RestaurantExists
	mock.lockRestaurantExists.RUnlock()
	return calls
}
